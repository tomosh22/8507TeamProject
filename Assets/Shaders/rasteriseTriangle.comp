#version 430 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;//todo change work groups
layout(	rgba16f, binding = 0) uniform image1D triDataTex;
layout(	r8ui, binding = 1) uniform uimage2D outputTex;

uniform vec3 sphereCenter;
uniform float sphereRadius;

uniform int textureWidth;
uniform int textureHeight;

uniform int teamID;

struct Triangle{
	float ax,ay,az,au,av;
	float bx,by,bz,bu,bv;
	float cx,cy,cz,cu,cv;
};

struct Edge{
	vec3 a;
	vec3 b;
};

uniform mat4 modelMatrix;

uniform vec3 point;

layout(std430, binding = 2) buffer Positions{
    float positions[];
};
layout(std430, binding = 3) buffer TexCoords{
    vec2 texCoords[];
};
layout(std430, binding = 4) buffer Indices{
    int indices[];
};


layout(std430, binding = 5) buffer TriangleSSBO{
	Triangle triangles[];
};
layout(std430, binding = 6) buffer DebugTriangleSSBO{
	Triangle debugTriangleSSBO[];
};
layout(std430, binding = 7) buffer TriangleBoolSSBO{
	bool triangleBoolSSBO[];
};

layout(std430, binding = 9) buffer TriangleRasteriseSSBO{
	uint triangleRasteriseSSBO[];
};


vec3 pointInTriangle(vec2 triA, vec2 triB, vec2 triC, vec2 point) {
    float areaABC = abs((triB.x - triA.x)*(triC.y - triA.y) - (triC.x - triA.x)*(triB.y - triA.y));
    float areaPBC = abs((triB.x - point.x)*(triC.y - point.y) - (triC.x - point.x)*(triB.y - point.y));
    float areaPCA = abs((triC.x - point.x)*(triA.y - point.y) - (triA.x - point.x)*(triC.y - point.y));
    float areaPAB = abs((triA.x - point.x)*(triB.y - point.y) - (triB.x - point.x)*(triA.y - point.y));

    vec3 barycentric;
    barycentric.x = areaPBC / areaABC;
    barycentric.y = areaPCA / areaABC;
    barycentric.z = areaPAB / areaABC;

    //return vec3(areaABC);
    if (abs((barycentric.x + barycentric.y + barycentric.z) - 1) < 0.1) {
        return barycentric;
    } else {
        return vec3(-1);
    }
}

bool pointInSphere(vec3 triA, vec3 triB, vec3 triC, vec3 barycentric){
    vec3 worldSpacePoint = (barycentric.x * triA) + (barycentric.y * triB) + (barycentric.z * triC);
    return length(worldSpacePoint - sphereCenter) < sphereRadius;
}





void main() {
    int invoc = int(gl_GlobalInvocationID.z);
    int id = int(triangleRasteriseSSBO[3 * invoc + 0]);
	Triangle tri = triangles[id];

    vec3 triA = vec3(tri.ax,tri.ay,tri.az);
    vec3 triB = vec3(tri.bx,tri.by,tri.bz);
    vec3 triC = vec3(tri.cx,tri.cy,tri.cz);

    vec2 uvA = vec2(tri.au,tri.av);
    vec2 uvB = vec2(tri.bu,tri.bv);
    vec2 uvC = vec2(tri.cu,tri.cv);

    vec2 texCoordA = vec2(uvA * vec2(textureWidth, textureHeight));
    vec2 texCoordB = vec2(uvB * vec2(textureWidth, textureHeight));
    vec2 texCoordC = vec2(uvC * vec2(textureWidth, textureHeight));
    
    vec3 barycentric;
    int x = int(gl_GlobalInvocationID.x);
    int y = int(gl_GlobalInvocationID.y);

    uvec2 topLeftCorner = uvec2(triangleRasteriseSSBO[3 * id + 1], triangleRasteriseSSBO[3 * id + 2]);

    if((barycentric = pointInTriangle(texCoordA,texCoordB,texCoordC,topLeftCorner + uvec2(x,y))) != vec3(-1)){
                
                if(pointInSphere(triA,triB,triC,barycentric)){
                    imageStore(triDataTex,id,vec4(1,1,1,1));
                    imageStore(outputTex,ivec2(x,y),uvec4(teamID,0,0,0));
                }
            }
            else{ imageStore(triDataTex,id,vec4(1,1,1,1)*2);}
    
    return;
}