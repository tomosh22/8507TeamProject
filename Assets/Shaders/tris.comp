#version 430 core
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;//todo change work groups
layout(	rgba16f, binding = 0) uniform image1D triDataTex;
layout(	r8ui, binding = 1) uniform uimage2D outputTex;

uniform vec3 sphereCenter;
uniform float sphereRadius;

uniform int textureWidth;
uniform int textureHeight;

uniform bool isComplex;

struct Triangle{
	float ax,ay,az,au,av;
	float bx,by,bz,bu,bv;
	float cx,cy,cz,cu,cv;
};

struct Edge{
	vec3 a;
	vec3 b;
};

uniform vec3 point;

layout(std430, binding = 5) buffer TriangleSSBO{
	Triangle triangles[];
};
layout(std430, binding = 6) buffer TriangleBoolSSBO{
	bool triangleBools[];
};


float GetAreaFromTriangleVerts(vec3 a, vec3 b, vec3 c) {
	vec3 v0 = b - a;
    vec3 v1 = c - a;
    vec3 crossProduct = cross(v0, v1);
    float area = 0.5 * length(crossProduct);
    return area;
}

vec3 WorldSpaceToBarycentricCoords(vec3 point, vec3 vertA, vec3 vertB, vec3 vertC) {
	vec3 barycentric;
	float totalArea = GetAreaFromTriangleVerts(vertA, vertB, vertC);
	barycentric.x = float(GetAreaFromTriangleVerts(point, vertB, vertC) / totalArea);
	barycentric.y = float(GetAreaFromTriangleVerts(vertA, point, vertC) / totalArea);
	barycentric.z = float(GetAreaFromTriangleVerts(vertA, vertB, point) / totalArea);
    //if(isnan(barycentric.x))barycentric.x = 0;
    //if(isnan(barycentric.y))barycentric.y = 0;
    //if(isnan(barycentric.z))barycentric.z = 0;
	return barycentric;
}

vec2 BarycentricToUV(vec3 barycentric, vec2 uvA, vec2 uvB, vec2 uvC){
    vec2 uv = vec2(0);
    uv += uvA * barycentric.x;
    uv += uvB * barycentric.y;
    uv += uvC * barycentric.z;
    return uv;
}

//#define NO_EDGE_TEST

bool sphereTriangleIntersection(vec3 sphereCenter, float sphereRadius,
                                vec3 v0, vec3 v1, vec3 v2,
                                out vec3 intersectionPoint)
{
    
    vec3 triangleNormal = normalize(cross(v1 - v0, v2 - v0));

    // Compute the distance of the sphere center to the triangle plane
    float distance = dot(triangleNormal, sphereCenter - v0);

    // Check if the sphere is behind or too far away from the triangle
    if (distance > sphereRadius || distance < -sphereRadius)
        return false;

    // Compute the projection of the sphere center onto the triangle plane
    vec3 projection = sphereCenter - distance * triangleNormal;

#ifndef NO_EDGE_TEST
    // Check if the projection is inside the triangle
    vec3 edge0 = v1 - v0;
    vec3 vp0 = projection - v0;
    if (dot(triangleNormal, cross(edge0, vp0)) < 0)
        return false;

    vec3 edge1 = v2 - v1;
    vec3 vp1 = projection - v1;
    if (dot(triangleNormal, cross(edge1, vp1)) < 0)
        return false;

    vec3 edge2 = v0 - v2;
    vec3 vp2 = projection - v2;
    if (dot(triangleNormal, cross(edge2, vp2)) < 0)
        return false;
#endif
    // Compute the intersection point
    float t = sphereRadius * sphereRadius - (length(sphereCenter - projection)) * 
              (length(sphereCenter - projection));

    //if (t < 0) return false;

    //intersectionPoint = projection - triangleNormal * sqrt(t);
    intersectionPoint = projection;

    return true;
}

bool EdgeIntersection(vec3 sphereCenter, float sphereRadius,
                                vec3 v0, vec3 v1, vec3 v2,
                                out vec3 intersectionPoint){
    if(!isComplex)return false;
	float furthestDistance = 0.;
	int furthestVert = -1;
	float newDistance;
	for(int i = 0;i < 3;i++){
		switch(i){
		case 0:
			newDistance = length(v0-point);
			if(newDistance > furthestDistance){
				furthestVert = i;
				furthestDistance = newDistance;
			}
			break;
		case 1:
			newDistance = length(v1-point);
			if(newDistance > furthestDistance){
				furthestVert = i;
				furthestDistance = newDistance;
			}
			break;
		case 2:
			newDistance = length(v2-point);
			if(newDistance > furthestDistance){
				furthestVert = i;
				furthestDistance = newDistance;
			}
			break;
		}
	}
	Edge edge;
	switch (furthestVert){
	case 0:
		edge.a = v1;
		edge.b = v2;
		break;
	case 1:
		edge.a = v2;
		edge.b = v0;
		break;
	case 2:
		edge.a = v0;
		edge.b = v1;
	}

    vec3 vertToSphereCenter = sphereCenter - edge.a;
    vec3 edgeDir = normalize(edge.b - edge.a);
    float sphereProj = dot(vertToSphereCenter, edgeDir);
    if(sphereProj < 0) return false;

    vec3 point = edge.a + edgeDir * sphereProj;

    float sphereDist = length(point - sphereCenter);
    if(sphereDist > sphereRadius)return false;
    intersectionPoint = point;
    return true;
    float offset = sqrt(sphereRadius * sphereRadius - sphereDist * sphereDist);
    intersectionPoint = edge.a + edgeDir * (sphereProj - offset);
    return true;

    
    if(length(edge.a - sphereCenter)<sphereRadius){
        intersectionPoint = edge.a;
        return true;
    }
    if(length(edge.b - sphereCenter)<sphereRadius){
        intersectionPoint = edge.b;
        return true;
    }
    return false;
	

}

bool BasicCollisionDetection(vec3 sphereCenter, float sphereRadius,
                                vec3 triA, vec3 triB, vec3 triC,
                                out vec3 intersectionPoint){
    vec3 point = vec3(0);
    int numHits = 0;
    if(length(triA - sphereCenter)<sphereRadius){
        point += triA;
        numHits++;
    }
    if(length(triB - sphereCenter)<sphereRadius){
        point += triB;
        numHits++;
    }
    if(length(triC - sphereCenter)<sphereRadius){
        point += triC;
        numHits++;
    }
    if(numHits > 0){
        point /= numHits;
        intersectionPoint = point;
        return true;
    }
    return false;
}

void main() {
	int id = int(gl_GlobalInvocationID.x);

    
    Triangle tri = triangles[id];
    vec3 intersectionPoint;

    vec3 triA = vec3(tri.ax,tri.ay,tri.az);
    vec3 triB = vec3(tri.bx,tri.by,tri.bz);
    vec3 triC = vec3(tri.cx,tri.cy,tri.cz);

    vec2 uvA = vec2(tri.au,tri.av);
    vec2 uvB = vec2(tri.bu,tri.bv);
    vec2 uvC = vec2(tri.cu,tri.cv);
    if(triA == triB && triA == triC && triB == triC && triA == vec3(0)){return;}

    /*if(BasicCollisionDetection(sphereCenter,sphereRadius,triA,triB,triC,intersectionPoint)){
        vec3 barycentric = WorldSpaceToBarycentricCoords(intersectionPoint,triA,triB,triC);
        vec2 uv = BarycentricToUV(barycentric, uvA, uvB, uvC);
        ivec2 IMAGE_COORDS = ivec2(uv.x * 1000,uv.y * 1000);
    	imageStore(triDataTex,id,vec4(uv,0,1));

        //imageStore(triDataTex,id,vec4(0,0,1,1));//debugging
        for(int x = -20; x < 21;x++){
            for(int y = -20; y < 21; y++){
                imageStore(outputTex,IMAGE_COORDS + ivec2(x,y),vec4(1));
            }
        }
        
    }
    else{
    	imageStore(triDataTex,id,vec4(1,0,0,1));
    }
    q
    return;*/
    

    if(sphereTriangleIntersection(sphereCenter,sphereRadius,triA,triB,triC,intersectionPoint) || EdgeIntersection(sphereCenter,sphereRadius,triA,triB,triC,intersectionPoint)){
    	vec3 barycentric = WorldSpaceToBarycentricCoords(intersectionPoint,triA,triB,triC);
        vec2 uv = BarycentricToUV(barycentric, uvA, uvB, uvC);
        ivec2 IMAGE_COORDS = ivec2(uv.x * textureWidth,uv.y * textureHeight) - ivec2(textureWidth,textureHeight)/4;
        float dist = length(intersectionPoint - sphereCenter);
    	imageStore(triDataTex,id,vec4(IMAGE_COORDS,0,dist));
        ivec2 area = ivec2(textureWidth,textureHeight)/40;
        //imageStore(triDataTex,id,vec4(0,0,1,1));//debugging
        for(int x = -area.x; x <= area.x;x++){
            for(int y = -area.y; y <= area.y; y++){
                if(y != 0 && x != 0){
                    imageStore(outputTex,IMAGE_COORDS + ivec2(x,y) + ivec2(textureWidth,textureHeight)/4,uvec4(1,0,0,0));
                }
            }
        }
        //imageStore(outputTex,IMAGE_COORDS,vec4(1,1,1,1));
    }
    else{
        imageStore(triDataTex,id,vec4(1,0,0,-999));
    }
   
    
    return;
}